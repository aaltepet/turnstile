#!/usr/bin/python

import ConfigParser
import os
import sys
import warnings

import argparse
from lxml import etree


# We need the database module and the utils from turnstile
poss_topdir = os.path.normpath(os.path.join(os.path.abspath(sys.argv[0]),
                                            os.pardir,
                                            os.pardir))
if os.path.exists(os.path.join(poss_topdir, 'turnstile', '__init__.py')):
    sys.path.insert(0, poss_topdir)


from turnstile import database
from turnstile import utils


def parse_limit(db, idx, limit):
    # First, try to import the class; this will raise ImportError if
    # we can't import it
    klass = utils.import_class(limit.get('class'))

    # Build the list of required attributes
    required = set(k for k, v in klass.attrs.items()
                   if 'default' not in v)

    # Now, use introspection on the class to interpret the attributes
    attrs = {}
    for child in limit:
        # Basic validation of child elements
        if child.tag != 'attr':
            warnings.warn("Unrecognized element %r while parsing limit at "
                          "index %d; ignoring..." % (child.tag, idx))
            continue

        # Get the attribute name
        attr = child.get('name')

        # Be liberal in what we accept--ignore unrecognized attributes
        # (with a warning)
        if attr not in klass.attrs:
            warnings.warn("Limit at index %d does not accept an attribute "
                          "%r; ignoring..." % (idx, attr))
            continue

        # OK, get the attribute descriptor
        desc = klass.attrs[attr]

        # Grab the attribute type
        attr_type = desc.get('type', str)

        if attr_type == list:
            # Lists are expressed as child elements; we ignore the
            # child element names
            subtype = desc.get('subtype', str)
            value = []
            for grandchild in child:
                if grandchild.tag != 'value':
                    warnings.warn("Unrecognized element %r while parsing "
                                  "%r attribute of limit at index %d; "
                                  "ignoring..." %
                                  (grandchild.tag, attr, idx))
                    continue

                value.append(subtype(grandchild.text))

            if len(value) <= 0:
                warnings.warn("Limit at index %d: Missing child elements "
                              "for attribute %r" % (idx, attr))
        elif attr_type == dict:
            # Dicts are expressed as child elements, with the tags
            # identifying the attribute name
            subtype = desc.get('subtype', str)
            value = {}
            for grandchild in child:
                if grandchild.tag != 'value':
                    warnings.warn("Unrecognized element %r while parsing "
                                  "%r attribute of limit at index %d; "
                                  "ignoring..." %
                                  (grandchild.tag, attr, idx))
                    continue
                elif 'key' not in grandchild.attrib:
                    warnings.warn("Missing 'key' attribute of 'value' "
                                  "element while parsing %r attribute of "
                                  "limit at index %d; ignoring..." %
                                  (attr, idx))
                    continue

                value[grandchild.get('key')] = subtype(grandchild.text)

            if len(value) <= 0:
                warnings.warn("Limit at index %d: Missing child elements "
                              "for attribute %r" % (idx, attr))
        else:
            # Simple type conversion
            value = attr_type(child.text)

        # Save the attribute
        attrs[attr] = value

        # Remove from the required set
        required.discard(attr)

    # Did we get all required attributes?
    if required:
        raise TypeError("Missing required attributes %s" %
                        (', '.join(repr(a) for a in sorted(required))))

    # OK, instantiate and return the class
    return klass(db, **attrs)


def main(config, limits_file, do_reload=True, dry_run=False, debug=False):
    # If dry_run is set, default debug to True
    if dry_run:
        debug = True

    # Instantiate the config parser
    cp = ConfigParser.SafeConfigParser()

    # Read the limits from the file
    cp.read(config)

    # Make sure we have a connection section
    if not cp.has_section('connection'):
        raise Exception("Missing [connection] section from %r" % config)

    # Parse the limits file
    limits_tree = etree.parse(limits_file)

    # Get the database configuration...
    config = dict(cp.items('connection'))
    limits_key = config.pop('limits_key', 'limits')
    control_channel = config.pop('control_channel', 'control')

    # Get the database connection
    db = database.initialize(config)

    # Now, we parse the limits XML file
    limits = []
    for idx, limit in enumerate(limits_tree.getroot()):
        # Skip tags we don't recognize
        if limit.tag != 'limit':
            if debug:
                print >>sys.stderr, ("Unrecognized tag %r in limits file" %
                                     limit.tag)
            continue

        # Construct the limit and add it to the list of limits
        try:
            limits.append(parse_limit(db, idx, limit))
        except Exception as exc:
            warnings.warn("Couldn't understand limit at index %d: %s" %
                          (idx, exc))
            continue

    # Now that we have the limits, let's install them
    if debug:
        print >>sys.stderr, "Installing the following limits:"
        for lim in limits:
            print >>sys.stderr, "  %r" % lim
    if not dry_run:
        db.limit_update(limits_key, limits)

    # Were we requested to reload the limits?
    if do_reload is False:
        return

    # OK, figure out what kind of reload to do
    params = []
    if do_reload is True:
        # Nothing to do; use default semantics
        pass
    elif (isinstance(do_reload, (int, long, float)) or
          (isinstance(do_reload, basestring) and do_reload.isdigit())):
        params = ['spread', do_reload]
    else:
        params = [str(do_reload)]

    # Issue the reload command
    if debug:
        cmd = ['reload']
        cmd.extend(params)
        print >>sys.stderr, ("Issuing command: %s" %
                             ' '.join(str(c) for c in cmd))
    if not dry_run:
        db.command(control_channel, 'reload', *params)


if __name__ == '__main__':
    parser = argparse.ArgumentParser(
        description="Set up or update limits in the Redis database.",
        )

    parser.add_argument('config',
                        help="Name of the configuration file, for connecting "
                        "to the Redis database.")
    parser.add_argument('limits_file',
                        help="Name of the XML file describing the limits to "
                        "configure.")
    parser.add_argument('--debug', '-d',
                        dest='debug',
                        action='store_true',
                        default=False,
                        help="Run the tool in debug mode.")
    parser.add_argument('--dryrun', '--dry_run', '--dry-run', '-n',
                        dest='dry_run',
                        action='store_true',
                        default=False,
                        help="Perform a dry run; inhibits loading data into "
                        "the database.")
    parser.add_argument('--noreload', '-R',
                        dest='reload',
                        action='store_false',
                        default=True,
                        help="Inhibit issuing a reload command.")
    parser.add_argument('--reload-immediate', '-r',
                        dest='reload',
                        action='store_const',
                        const='immediate',
                        help="Cause all nodes to immediately reload the "
                        "limits configuration.")
    parser.add_argument('--reload-spread', '-s',
                        dest='reload',
                        metavar='SECS',
                        type=float,
                        action='store',
                        help="Cause all nodes to reload the limits "
                        "configuration over the specified number of seconds.")

    args = parser.parse_args()
    try:
        main(args.config, args.limits_file, args.reload, args.dry_run,
             args.debug)
    except Exception as exc:
        if args.debug:
            raise
        sys.exit(str(exc))

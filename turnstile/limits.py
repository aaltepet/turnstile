import math
import time

from turnstile import utils


# Recognized units and their names and aliases
_units_list = [
    (1, ('second', 'seconds', 'secs', 'sec', 's')),
    (60, ('minute', 'minutes', 'mins', 'min', 'm')),
    (60 * 60, ('hour', 'hours', 'hrs', 'hr', 'h')),
    (60 * 60 * 24, ('day', 'days', 'd')),
    ]


# Build up a mapping of units to names and vice versa
_units_map = {}
for secs, names in _units_list:
    _units_map[secs] = names[0]
    for name in names:
        _units_map[name] = secs


def get_unit_value(name):
    """Given a unit's name, return its value."""

    # Numbers map to numbers
    if isinstance(name, (int, long)):
        return name

    # Only accept strings from here on
    if not isinstance(name, basestring):
        raise TypeError('name must be a string.')

    # Again, numbers map to numbers
    if name.isdigit():
        return int(name)

    # Look it up in the units map
    return _units_map[name.lower()]


def get_unit_name(value):
    """Given a unit's value, return its name."""

    # Return name if we have one, otherwise stringify value
    return _units_map.get(value, str(value))


class LimitMeta(type):
    """
    Metaclass for limits.
    """

    _registry = {}

    def __new__(mcs, name, bases, namespace):
        """
        Generate a new Limit class.  Adds the full class name to the
        namespace, for the benefit of dehydrate().  Also registers the
        class in the registry, for the benefit of hydrate().
        """

        # Build the full name
        full_name = '%s:%s' % (namespace['__module__'], name)

        # Add it to the namespace
        namespace['_limit_full_name'] = full_name

        # Augment the attrs set...
        if 'attrs' in namespace:
            attrs = namespace['attrs']
            for base in bases:
                # If a given base class has 'attrs', union with that
                # set of attributes
                try:
                    attrs |= getattr(base, 'attrs')
                except AttributeError:
                    # Ignore it if the base class doesn't have
                    # 'attrs'...
                    pass

        # Create the class
        cls = super(LimitMeta, mcs).__new__(mcs, name, bases, namespace)

        # Register the class
        if full_name not in mcs._registry:
            mcs._registry[full_name] = cls

        return cls


class Limit(object):
    """
    Base class for representing limits.  All limits should derive from
    this class.
    """

    __metaclass__ = LimitMeta

    attrs = set(['uri', 'value', 'unit', 'verbs'])

    def __init__(self, uri, value, unit, verbs=None):
        """
        Initialize a new limit.

        :param uri: A routes-compatible URI specification.  Parsed
                    keys will be used as part of the cache key.
        :param value: Integer giving number of requests which can be
                      made during a unit of time.
        :param unit: Unit of time over which to limit the number of
                     requests.  May be an integer (either in native
                     Python int or a string representation) or one of
                     the pre-defined units, such as "minute."
        :param verbs: List of HTTP verbs the limit should be
                      considered for.  If empty or not specified, all
                      hits against the specified URI will be limited.
        """

        self.uri = uri
        self._value = value
        self._unit = get_unit_value(unit)
        self.verbs = verbs or []

        # Sanity-check value and unit
        if self._value <= 0:
            raise ValueError("Limit value must be > 0")
        elif self._unit <= 0:
            raise ValueError("Unit value must be > 0")

    @classmethod
    def hydrate(cls, limit):
        """
        Given a limit dict, as generated by dehydrate(), generate an
        appropriate instance of Limit (or a subclass).  If the
        required limit class cannot be found, returns None.
        """

        # Extract the limit name from the keyword arguments
        cls_name = limit.pop('limit_class')

        # Is it in the registry yet?
        if cls_name not in cls._registry:
            try:
                utils.import_class(cls_name)
            except ImportError:
                # If we failed to import, ignore...
                pass

        # Look it up in the registry
        cls = cls._registry.get(cls_name)

        # Instantiate the thing
        return cls(**limit) if cls else None

    def dehydrate(self):
        """Return a dict representing this limit."""

        # Only concerned about very specific attributes
        result = dict(limit_class=self._limit_full_name)
        for attr in self.attrs:
            # Using getattr allows the properties to come into play
            result[attr] = getattr(self, attr)

        return result

    @property
    def value(self):
        """Retrieve the value for this limit."""

        return self._value

    @value.setter
    def value(self, value):
        """Change the value for this limit."""

        if value <= 0:
            raise ValueError("Limit value must be > 0")

        self._value = value

    @property
    def unit(self):
        """Retrieve the name of the unit used for this limit."""

        return get_unit_name(self._unit)

    @unit.setter
    def unit(self, value):
        """
        Change the unit for this limit to the specified unit.  The new
        value may be specified as an integer, a string the indicating
        number of seconds, or one of the recognized unit names.
        """

        self.unit_value = get_unit_value(value)

    @property
    def unit_value(self):
        """
        Retrieve the unit used for this limit as an integer number of
        seconds.
        """

        return self._unit

    @unit_value.setter
    def unit_value(self, value):
        """
        Change the unit used for this limit to the given number of
        seconds.
        """

        if value <= 0:
            raise ValueError("Unit value must be > 0")

        self._unit = int(value)

    @property
    def increment(self):
        """
        Retrieve the amount by which a request increases the water
        level.
        """

        return self.unit_value / self.value


class Bucket(object):
    attrs = set(['last', 'next', 'level'])

    def __init__(self, limit, key, last=None, next=None, level=0):
        """
        Initialize a bucket.

        :param limit: The limit associated with this bucket.
        :param key: The key under which this bucket should be stored.
        :param last: The timestamp of the last request.
        :param next: The timestamp of the next permissible request.
        :param level: The current water level in the bucket.
        """

        self.limit = limit
        self.key = key
        self.last = last
        self.next = next
        self.level = level

    @classmethod
    def hydrate(cls, limit, key, bucket):
        """
        Given a key and a bucket dict, as generated by dehydrate(),
        generate an appropriate instance of Bucket.
        """

        return cls(limit=limit, key=key, **bucket)

    def dehydrate(self):
        """Return a dict representing this bucket."""

        # Only concerned about very specific attributes
        result = {}
        for attr in self.attrs:
            result[attr] = getattr(self, attr)

        return result

    def delay(self):
        """Determine delay until next request."""

        now = time.time()

        # Initialize last...
        if not self.last:
            self.last = now

        # How much has leaked out?
        leaked = now - self.last

        # Update the last message time
        self.last = now

        # Update the water level
        self.level = max(self.level - leaked, 0)

        # Are we too full?
        difference = self.level + self.limit.increment - self.limit.unit_value
        if difference > 0:
            self.next = now + difference
            return difference

        # OK, raise the water level and set next to an appropriate
        # value
        self.level += self.limit.increment
        self.next = now

        return 0.0

    @property
    def remaining(self):
        """Return remaining level."""

        return int(math.floor(((self.limit.unit_value - self.level) /
                               self.limit.unit_value) * self.limit.value))
